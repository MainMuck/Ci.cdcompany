# .github/workflows/build-sign-verify.yml
name: C1-M1-L1 | build, sign, checksums, verify (warn)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

# [Критерий 1][Метрика М1][Уровень L1]
# Зачем: минимум прав, чтобы собрать+подписать артефакт и проверить его (WARN).
permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  unit_tests:
    runs-on: ubuntu-latest
    steps:
      # [К1][М1][Л1] Зачем: взять код.
      - uses: actions/checkout@v4

      # [К1][М1][Л1] Зачем: нужная версия Python для тестов.
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      # [К1][М1][Л1] Зачем: установить зависимости и pytest.
      - run: pip install -r requirements.txt pytest

      # [К1][М1][Л1] Зачем (INFRA): гарантировать корректные импорты в CI.
      - name: Run unit tests (К1–М1–Л1 infra)
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_VERSION: dev
        run: python -m pytest -q

  build_and_sign:
    # [К1][М1][Л1] Зачем: собрать контейнерный артефакт, ПОДПИСАТЬ его (keyless по OIDC), и опубликовать checksums.
    needs: unit_tests
    runs-on: ubuntu-latest
    outputs:
      image_ref: ${{ steps.compute.outputs.image_ref }}
      image: ${{ steps.img.outputs.image }}
    steps:
      # [К1][М1][Л1] Зачем: получить исходники.
      - uses: actions/checkout@v4

      # [К1][М1][Л1] Зачем: вычислить имя образа GHCR АВТОМАТИЧЕСКИ (нижний регистр) через bash.
      - name: Compute IMAGE (auto, lowercase) [К1][М1][Л1]
        id: img
        shell: bash
        run: |
          echo "image=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      # [К1][М1][Л1] Зачем: авторизация для публикации образа в GHCR.
      - name: Login to GHCR [К1][М1][Л1]
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # [К1][М1][Л1] Зачем: builder для стабильной/кэшируемой сборки.
      - name: Set up Buildx [К1][М1][Л1]
        uses: docker/setup-buildx-action@v3

      # [К1][М1][Л1] Подтребование «Подписываем артефакт» — подготовка:
      # Зачем: собрать и ЗАПУШИТЬ образ с ТЕГОМ; дайджест вернётся в outputs.
      - name: Build and push image (tagged) [К1][М1][Л1]
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.img.outputs.image }}:ci-l1

      # [К1][М1][Л1] Зачем: сформировать канонический ref image@sha256:... для подписи и verify.
      - name: Compute image ref [К1][М1][Л1]
        id: compute
        shell: bash
        run: echo "image_ref=${{ steps.img.outputs.image }}@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      # [К1][М1][Л1] Зачем: установить cosign (подпись/верификация).
      - name: Install cosign [К1][М1][Л1]
        uses: sigstore/cosign-installer@v3

      # [К1][М1][Л1] Подтребование «Подписываем артефакт» — ИСПОЛНЕНИЕ:
      # Зачем: keyless-подпись (Fulcio/Rekor) ПО ДАЙДЖЕСТУ (без двусмысленности тегов).
      - name: Keyless sign image (Fulcio/Rekor) [К1][М1][Л1]
        run: cosign sign --yes "${{ steps.compute.outputs.image_ref }}"

      # (Необяз.) [К1][М1][Л1] Зачем: минимальная attestation происхождения.
      - name: Create minimal provenance predicate [К1][М1][Л1]
        run: |
          cat > predicate.json <<'JSON'
          {"_type":"https://in-toto.io/Statement/v0.1","predicateType":"https://slsa.dev/provenance/v1",
           "predicate":{"builder":{"id":"github-actions"},"buildType":"container-build",
           "invocation":{"id":"${{ github.run_id }}",
             "parameters":{"repo":"${{ github.repository }}","sha":"${{ github.sha }}"}}}}
          JSON

      # [К1][М1][Л1] Подтребование «Публикуем checksums»:
      # Зачем: digest образа и sha256 файлов-артефактов (SBOM, predicate).
      - name: Generate SBOM (CycloneDX) [К1][М1][Л1]
        uses: anchore/sbom-action@v0
        with:
          format: cyclonedx-json
          output-file: sbom.cdx.json

      - name: Generate checksums & digest list [К1][М1][Л1]
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ steps.compute.outputs.image_ref }}" > IMAGE_DIGEST.txt
          sha256sum sbom.cdx.json > sbom.cdx.json.sha256
          sha256sum predicate.json > predicate.json.sha256
          {
            printf "artifact=IMAGE\tdigest=%s\n" "${{ steps.build.outputs.digest }}"
            printf "artifact=sbom.cdx.json\tsha256=%s\n" "$(cut -d' ' -f1 sbom.cdx.json.sha256)"
            printf "artifact=predicate.json\tsha256=%s\n" "$(cut -d' ' -f1 predicate.json.sha256)"
          } > checksums.txt

      # [К1][М1][Л1] Зачем: сохранить артефакты для этапа verify.
      - name: Upload checksums & related artifacts [К1][М1][Л1]
        uses: actions/upload-artifact@v4
        with:
          name: c1-m1-l1-checks
          path: |
            IMAGE_DIGEST.txt
            checksums.txt
            sbom.cdx.json
            sbom.cdx.json.sha256
            predicate.json
            predicate.json.sha256

  verify_non_blocking:
    # [К1][М1][Л1] Подтребование: «Перед Promote/Deploy — verify(hash+sig) против локального trust-store (WARN)»
    needs: build_and_sign
    runs-on: ubuntu-latest
    steps:
      # [К1][М1][Л1] Зачем: взять код (для чтения workflow_ref) и артефакты.
      - uses: actions/checkout@v4

      - name: Download checks artifacts [К1][М1][Л1]
        uses: actions/download-artifact@v4
        with:
          name: c1-m1-l1-checks

      # [К1][М1][Л1] Зачем: cosign для verify.
      - uses: sigstore/cosign-installer@v3

      # [К1][М1][Л1] Локальный TRUST-STORE (АВТО):
      # Зачем: пин на ТОТ ЖЕ workflow@ref (owner/repo/.github/workflows/…@refs/heads/main) и фиксированный issuer.
      - name: Compute local trust-store (auto) [К1][М1][Л1]
        id: trust
        shell: bash
        run: |
          echo "CERT_IDENTITY=https://github.com/${GITHUB_WORKFLOW_REF}" >> "$GITHUB_OUTPUT"
          echo "OIDC_ISSUER=https://token.actions.githubusercontent.com" >> "$GITHUB_OUTPUT"

      # [К1][М1][Л1] verify(SIG) — WARN-only: проверяем подпись по локальному trust-store.
      - name: Verify signature (WARN-only, pinned identity) [К1][М1][Л1]
        continue-on-error: true
        run: |
          cosign verify \
            --certificate-identity "${{ steps.trust.outputs.CERT_IDENTITY }}" \
            --certificate-oidc-issuer "${{ steps.trust.outputs.OIDC_ISSUER }}" \
            "${{ needs.build_and_sign.outputs.image_ref }}"

      # [К1][М1][Л1] verify(HASH) — WARN-only: проверяем sha256 артефактов.
      - name: Verify checksums (WARN-only) [К1][М1][Л1]
        continue-on-error: true
        run: |
          sha256sum -c sbom.cdx.json.sha256
          sha256sum -c predicate.json.sha256

  persist_evidence:
    # [INFRA][EVIDENCE] Сохраняем ВСЁ в ветку evidence, даже если предыдущие упали
    needs: [verify_non_blocking]
    if: always()
    runs-on: ubuntu-latest

    # [INFRA][EVIDENCE] Права, чтобы коммитить в репозиторий
    permissions:
      contents: write

    steps:
      # [INFRA][EVIDENCE] Берём репозиторий (дефолтную ветку), потом переключимся на evidence
      - name: Checkout default branch [INFRA][EVIDENCE]
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # [INFRA][EVIDENCE] Создаём/переключаемся на ветку evidence (если нет — будет создана)
      - name: Switch/Create evidence branch [INFRA][EVIDENCE]
        run: |
          git checkout -B evidence

      # [INFRA][EVIDENCE] Готовим каталог для ТЕКУЩЕГО run
      - name: Prepare destination [INFRA][EVIDENCE]
        id: prep
        run: |
          RUN_ID='${{ github.run_id }}'
          METRIC="M1-L1"
          DEST="evidence/${METRIC}/run-${RUN_ID}"
          mkdir -p "$DEST"
          echo "dest=$DEST"   >> "$GITHUB_OUTPUT"
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"

      # [INFRA][EVIDENCE] Скачаем ЛОГИ КАЖДОГО JOB (unit_tests, build_and_sign, verify_non_blocking, и т.п.)
      - name: Download job logs (ZIP per job) [INFRA][EVIDENCE]
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          sudo apt-get update -y && sudo apt-get install -y jq >/dev/null
          OWNER_REPO="${{ github.repository }}"
          RUN_ID="${{ steps.prep.outputs.run_id }}"
          API="https://api.github.com/repos/${OWNER_REPO}/actions/runs/${RUN_ID}/jobs?per_page=100"
          mkdir -p "${{ steps.prep.outputs.dest }}/logs"
          curl -sSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$API" > jobs.json
          jq -r '.jobs[] | "\(.id)\t\(.name)"' jobs.json | while IFS=$'\t' read -r JID JNAME; do
            if [ "$JNAME" = "persist_evidence" ]; then continue; fi
            SAFE_NAME=$(echo "$JNAME" | tr ' /' '__')
            curl -sSL \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${OWNER_REPO}/actions/jobs/${JID}/logs" \
              -o "${{ steps.prep.outputs.dest }}/logs/${SAFE_NAME}-${JID}.zip" || true
          done

      # [INFRA][EVIDENCE] (Дополнительно) Полный ZIP всех логов run'а одной пачкой
      - name: Download whole run logs (single ZIP) [INFRA][EVIDENCE]
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          curl -sSL \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/logs" \
            -o "${{ steps.prep.outputs.dest }}/logs-${{ github.run_id }}.zip" || true

      # [К1][М1][Л1][EVIDENCE] Артефакт с чексумами из ЭТОГО ЖЕ run (если публиковался)
      - name: Download evidence artifact (c1-m1-l1-checks) [К1][М1][Л1][EVIDENCE]
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: c1-m1-l1-checks
          run-id: ${{ github.run_id }}
          path: ${{ steps.prep.outputs.dest }}/artifact

      # [INFRA][EVIDENCE] Снимок текущего workflow YAML для трассируемости
      - name: Snapshot workflow file [INFRA][EVIDENCE]
        run: |
          mkdir -p "${{ steps.prep.outputs.dest }}/workflow"
          cp -a .github/workflows/build-sign-verify.yml "${{ steps.prep.outputs.dest }}/workflow/" || true

      # [INFRA][EVIDENCE] Метаданные для проверяющего (Run/Commit/Conclusion)
      - name: Write metadata (README) [INFRA][EVIDENCE]
        run: |
          cat > "${{ steps.prep.outputs.dest }}/README.txt" <<EOF
          Evidence bundle for C1/M1/L1
          Repo:        ${{ github.repository }}
          Workflow:    ${{ github.workflow }}
          Run ID:      ${{ github.run_id }}
          Run number:  ${{ github.run_number }}
          Attempt:     ${{ github.run_attempt }}
          Conclusion:  ${{ job.status }}
          Commit SHA:  ${{ github.sha }}

          Contents:
          - logs/*.zip                       → логи по каждому job текущего run
          - logs-<RUN_ID>.zip                → общий ZIP всех логов run (дублирует per-job)
          - artifact/ (если есть)            → IMAGE_DIGEST.txt, checksums.txt, *.sha256, sbom.cdx.json, predicate.json
          - workflow/build-sign-verify.yml   → снимок WF с комментариями
          EOF

      # [INFRA][EVIDENCE] Коммитим и пушим в ветку evidence
      - name: Commit & push to evidence [INFRA][EVIDENCE]
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Evidence: C1/M1/L1 for run ${{ github.run_id }} (${{ job.status }})" || echo "No changes to commit"
          git push origin evidence
