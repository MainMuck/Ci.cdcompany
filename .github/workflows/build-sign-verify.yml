# .github/workflows/build-sign-verify.yml
name: C1-M1-L1 | build, sign, checksums, verify (warn)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

# [Критерий 1][Метрика М1][Уровень L1]
# Зачем: минимум прав, чтобы собрать/подписать и проверить артефакт.
permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  unit_tests:
    runs-on: ubuntu-latest
    steps:
      # [К1][М1][L1] Зачем: взять код для сборки и тестов.
      - uses: actions/checkout@v4

      # [К1][М1][L1] Зачем: установить нужную версию Python для тестов.
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      # [К1][М1][L1] Зачем: поставить зависимости и pytest.
      - run: pip install -r requirements.txt pytest

      # [К1][М1][L1] Зачем: гарантировать, что импорт app.main работает на раннере (PYTHONPATH).
      - name: Run unit tests (К1-М1-L1 infra)
        env:
          PYTHONPATH: ${{ github.workspace }}
          APP_VERSION: dev
        run: python -m pytest -q

  build_and_sign:
    # [К1][М1][L1] Зачем: построить контейнерный артефакт, ПОДПИСАТЬ его (keyless), опубликовать checksums.
    needs: unit_tests
    runs-on: ubuntu-latest
    outputs:
      image_ref: ${{ steps.compute.outputs.image_ref }}
      image: ${{ steps.img.outputs.image }}
    steps:
      # [К1][М1][L1] Зачем: взять исходники для сборки.
      - uses: actions/checkout@v4

      # [К1][М1][L1] Зачем: автоматически вычислить имя образа GHCR для текущего репо.
      # ВАЖНО: GHCR требует нижний регистр -> используем bash-понижение регистра.
      - name: Compute IMAGE (auto, lowercase) [К1][М1][L1]
        id: img
        shell: bash
        run: |
          echo "image=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      # [К1][М1][L1] Зачем: авторизоваться в GHCR для публикации артефакта.
      - name: Login to GHCR [К1][М1][L1]
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # [К1][М1][L1] Зачем: builder для кэшируемой и быстрой сборки образа.
      - name: Set up Buildx [К1][М1][L1]
        uses: docker/setup-buildx-action@v3

      # [К1][М1][L1] Подтребование «Подписываем артефакт» — подготовка:
      # Зачем: собрать и запушить образ ПО ДАЙДЖЕСТУ → получим image@sha256:... (канонический ref для подписи/verify).
      - name: Build and push image (by digest) [К1][М1][L1]
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.img.outputs.image }}:ci-l1
          outputs: type=image,name=${{ steps.img.outputs.image }},push-by-digest=true,name-canonical=true

      # [К1][М1][Л1] Зачем: сформировать полный reference image@sha256:... для дальнейшей подписи и verify.
      - name: Compute image ref [К1][М1][L1]
        id: compute
        shell: bash
        run: echo "image_ref=${{ steps.img.outputs.image }}@${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      # [К1][М1][L1] Зачем: установить cosign — нативный инструмент подписи/проверки (Sigstore).
      - name: Install cosign [К1][М1][L1]
        uses: sigstore/cosign-installer@v3

      # [К1][М1][L1] Подтребование «Подписываем артефакт» — ИСПОЛНЕНИЕ:
      # Зачем: keyless-подписание через OIDC (Fulcio/Rekor) ПО ДАЙДЖЕСТУ.
      - name: Keyless sign image (Fulcio/Rekor) [К1][М1][L1]
        env: { COSIGN_EXPERIMENTAL: "true" }
        run: cosign sign --yes --keyless "${{ steps.compute.outputs.image_ref }}"

      # (Доп.) [К1][М1][L1] Зачем: минимальная attestation для происхождения (не требуется L1, но полезно).
      - name: Create minimal provenance predicate [К1][М1][L1]
        run: |
          cat > predicate.json <<'JSON'
          {"_type":"https://in-toto.io/Statement/v0.1","predicateType":"https://slsa.dev/provenance/v1",
           "predicate":{"builder":{"id":"github-actions"},"buildType":"container-build",
           "invocation":{"id":"${{ github.run_id }}",
             "parameters":{"repo":"${{ github.repository }}","sha":"${{ github.sha }}"}}}}
          JSON

      # [К1][М1][L1] Подтребование «Публикуем checksums»:
      # Зачем: опубликовать digest образа как checksum + sha256 для файлов-артефактов.
      - name: Generate SBOM (CycloneDX) [К1][М1][L1]
        uses: anchore/sbom-action@v0
        with:
          format: cyclonedx-json
          output-file: sbom.cdx.json

      - name: Generate checksums & digest list [К1][М1][L1]
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ steps.compute.outputs.image_ref }}" > IMAGE_DIGEST.txt
          sha256sum sbom.cdx.json > sbom.cdx.json.sha256
          sha256sum predicate.json > predicate.json.sha256
          {
            printf "artifact=IMAGE\tdigest=%s\n" "${{ steps.build.outputs.digest }}"
            printf "artifact=sbom.cdx.json\tsha256=%s\n" "$(cut -d' ' -f1 sbom.cdx.json.sha256)"
            printf "artifact=predicate.json\tsha256=%s\n" "$(cut -d' ' -f1 predicate.json.sha256)"
          } > checksums.txt

      # [К1][М1][L1] Зачем: сохранить артефакты (checksums, SBOM, predicate) для дальнейшего verify.
      - name: Upload checksums & related artifacts [К1][М1][L1]
        uses: actions/upload-artifact@v4
        with:
          name: c1-m1-l1-checks
          path: |
            IMAGE_DIGEST.txt
            checksums.txt
            sbom.cdx.json
            sbom.cdx.json.sha256
            predicate.json
            predicate.json.sha256

  verify_non_blocking:
    # [К1][М1][L1] Подтребование «Перед Promote/Deploy — verify(hash+sig) ПРОТИВ локального trust-store (WARN)»
    needs: build_and_sign
    runs-on: ubuntu-latest
    steps:
      # [К1][М1][L1] Зачем: взять код (для чтения workflow_ref) и скачать артефакты проверки.
      - uses: actions/checkout@v4

      - name: Download checks artifacts [К1][М1][L1]
        uses: actions/download-artifact@v4
        with:
          name: c1-m1-l1-checks

      # [К1][М1][L1] Зачем: cosign для verify.
      - uses: sigstore/cosign-installer@v3

      # [К1][М1][L1] Локальный TRUST-STORE (АВТО):
      # Зачем: жёстко ограничить доверие issuer'ом GitHub и пином НА КОНКРЕТНЫЙ workflow@ref текущего репо.
      - name: Compute local trust-store (auto) [К1][М1][L1]
        id: trust
        shell: bash
        run: |
          # GitHub даёт workflow_ref в формате: owner/repo/.github/workflows/file.yml@refs/heads/branch
          echo "CERT_IDENTITY=https://github.com/${GITHUB_WORKFLOW_REF}" >> "$GITHUB_OUTPUT"
          echo "OIDC_ISSUER=https://token.actions.githubusercontent.com" >> "$GITHUB_OUTPUT"

      # [К1][М1][L1] verify(SIG) — WARN-only:
      # Зачем: проверить подпись образа по локальному trust-store (issuer + pinned identity).
      - name: Verify signature (WARN-only, pinned identity) [К1][М1][L1]
        continue-on-error: true
        run: |
          cosign verify \
            --certificate-identity "${{ steps.trust.outputs.CERT_IDENTITY }}" \
            --certificate-oidc-issuer "${{ steps.trust.outputs.OIDC_ISSUER }}" \
            "${{ needs.build_and_sign.outputs.image_ref }}"

      # [К1][М1][L1] verify(HASH) — WARN-only:
      # Зачем: сверить sha256 для файлов-артефактов (SBOM, predicate).
      - name: Verify checksums (WARN-only) [К1][М1][L1]
        continue-on-error: true
        run: |
          sha256sum -c sbom.cdx.json.sha256
          sha256sum -c predicate.json.sha256
