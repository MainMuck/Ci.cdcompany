name: Security Framework Gates

on:
  push:
    branches: ["main", "release/*"]
    tags: ["v*"]
  pull_request:
    branches: ["main", "release/*"]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *" # каждые 6 часов авто-синк trust-store (org → репо)

permissions:
  contents: read
  security-events: write
  packages: read
  id-token: write
  attestations: write

env:
  ENFORCEMENT: ${{ github.ref_name == github.event.repository.default_branch && 'block' || 'warn' }}
  CAN_ATTEST: ${{ (github.event_name == 'push') || (github.event_name == 'workflow_dispatch') || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}

jobs:
  # ---------------- SAST / SCA presence ----------------
  codeql:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - uses: github/codeql-action/init@192325c86100d080feab897ff886c34abd4c83a3
        with:
          languages: "actions, javascript, python"
      - uses: github/codeql-action/analyze@192325c86100d080feab897ff886c34abd4c83a3

  dependency_review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Compute base/head refs
        id: deprefs
        shell: bash
        run: |
          set -euo pipefail
          HEAD_SHA="${GITHUB_SHA}"
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            BEFORE="$(jq -r .before "$GITHUB_EVENT_PATH")"
            if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
              echo "base=$BEFORE" >> "$GITHUB_OUTPUT"
            else
              git fetch --no-tags --prune --depth=2 origin "${GITHUB_REF}"
              echo "base=$(git rev-parse "${HEAD_SHA}^" 2>/dev/null || echo '')" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "base=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")" >> "$GITHUB_OUTPUT"
          fi
      - uses: actions/dependency-review-action@595b5aeba73380359d98a5e087f648dbb0edce1b
        if: steps.deprefs.outputs.base != ''
        with:
          base-ref: ${{ steps.deprefs.outputs.base }}
          head-ref: ${{ github.sha }}
          fail-on-severity: critical
        continue-on-error: ${{ env.ENFORCEMENT != 'block' }}

  # --------------- Verify action publishers (allow-list + pin) ---------------
  verify_action_publishers:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Verify publishers + pin to commit
        env:
          GH_TOKEN: ${{ github.token }}
          ALLOW_OWNERS: actions,github,dependabot,aws-actions,google-github-actions,azure
        shell: bash
        run: |
          set -euo pipefail
          sudo curl -fsSL -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          status=0
          mapfile -t WF < <(git ls-files '.github/workflows/*.y*ml' 2>/dev/null || true)
          for f in "${WF[@]}"; do
            while read -r owner repo ref; do
              [ -z "$owner" ] && continue
              case ",$ALLOW_OWNERS," in *,"$owner",*) ;; *) echo "::warning file=$f::owner '$owner' not in allow-list"; status=1;; esac
              [[ "$ref" =~ ^[0-9a-f]{40}$ ]] || { echo "::warning file=$f::'$owner/$repo@$ref' not pinned to full SHA"; status=1; }
              data=$(gh api "repos/$owner/$repo" -H "Accept: application/vnd.github+json" || true)
              [ "$(jq -r 'try .owner.is_verified // false' <<<"$data")" = "true" ] || { echo "::warning file=$f::owner '$owner' not verified"; status=1; }
            done < <(yq -r '.. | .uses? | select(type=="string")' "$f" | awk -F'[@/]' '{ if (NF>=3) printf "%s %s %s\n",$1,$2,$NF }')
          done
          [ $status -eq 0 ] || { [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }

  # ---------------- Build + SBOM + Attest ----------------
  build_and_attest:
    needs: [codeql, dependency_review, verify_action_publishers]
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Build artifact
        run: |
          echo "hello $(date -u +%FT%TZ)" > artifact.txt
          sha256sum artifact.txt | tee checksums.txt

      - name: Export SBOM (Syft)
        shell: bash
        run: |
          set -euo pipefail
          VER="v1.33.0"
          curl -fsSL -o syft.tgz https://github.com/anchore/syft/releases/download/${VER}/syft_${VER#v}_linux_amd64.tar.gz || \
          curl -fsSL -o syft.tgz https://github.com/anchore/syft/releases/download/${VER}/syft_Linux_x86_64.tar.gz
          tar -xzf syft.tgz syft && sudo install -m0755 syft /usr/local/bin/syft
          syft "file:artifact.txt" -o spdx-json=sbom.spdx.json
          D=$(sha256sum artifact.txt | awk '{print $1}')
          jq --arg d "$D" '.files=((.files // [])|map(select(.fileName!="artifact.txt")))+
             [{"fileName":"artifact.txt","SPDXID":"SPDXRef-File-artifact.txt","checksums":[{"algorithm":"SHA256","checksumValue":$d}]}]' \
             sbom.spdx.json > t && mv t sbom.spdx.json

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: build
          path: |
            artifact.txt
            checksums.txt
            sbom.spdx.json

      - name: Attest provenance
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-build-provenance@ef244123eb79f2f7a7e75d99086184180e6d0018
        with:
          subject-path: artifact.txt

      - name: Attest SBOM
        if: env.CAN_ATTEST == 'true'
        uses: actions/attest-sbom@5026d3663739160db546203eeaffa6aa1c51a4d6
        with:
          subject-path: artifact.txt
          sbom-path: sbom.spdx.json

      - name: Verify attestations
        if: env.CAN_ATTEST == 'true'
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          set -euo pipefail
          if ! gh attestation --help >/dev/null 2>&1; then gh extension install github/gh-attestation; fi
          WF="${GITHUB_WORKFLOW_REF}"
          for PT in "https://slsa.dev/provenance/v1" "https://spdx.dev/Document"; do
            ok=0
            for i in $(seq 1 8); do
              gh attestation verify artifact.txt \
                --repo "${{ github.repository }}" \
                --predicate-type "$PT" \
                --cert-oidc-issuer "https://token.actions.githubusercontent.com" \
                --signer-workflow "$WF" \
                --deny-self-hosted-runners --limit 50 && { ok=1; break; }
              sleep 10
            done
            [ $ok -eq 1 ] || { echo "::warning::verify failed for $PT"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }
          done

  # ---------------- Trust-store (JWKS / allowed_signers / revocations) ----------------
  trust_store_guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Load org trust-store (if set)
        id: t
        shell: bash
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
        run: |
          set -euo pipefail
          mkdir -p .github/trust
          if [ -n "${ORG_TRUST_REPO:-}" ]; then
            gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q || true
            if [ -f _orgtrust/.github/trust/publishers.jwks.json ]; then
              cp -r _orgtrust/.github/trust/* .github/trust/ || true
              echo "source=org" >> "$GITHUB_OUTPUT"
            else
              echo "source=local" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "source=local" >> "$GITHUB_OUTPUT"
          fi

      - name: Validate trust-store files
        env:
          AWS_KMS_KEY_ID: ${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          test -f .github/trust/publishers.jwks.json || { echo "::error::JWKS missing"; exit 1; }
          jq -e '.keys|length>0' .github/trust/publishers.jwks.json >/dev/null
          test -f .github/trust/allowed_signers.json || { echo "::error::allowed_signers.json missing"; exit 1; }
          test -f .github/trust/revocations.json || { echo "::group::revocations.json missing -> treat as empty"; echo '{"kids":[]}' > .github/trust/revocations.json; echo "::endgroup::"; }
          if [ -n "${AWS_KMS_KEY_ID:-}" ]; then
            K="AWS:${AWS_KMS_KEY_ID}"
            jq -r '.keys[].kid' .github/trust/publishers.jwks.json | grep -Fx "$K" >/dev/null || {
              echo "::warning::KID mismatch (expected $K)"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }
          fi

  # ---------------- KMS sign + verify ----------------
  kms_sign_and_verify:
    needs: [build_and_attest, trust_store_guard]
    runs-on: ubuntu-latest
    continue-on-error: ${{ github.ref_name != github.event.repository.default_branch }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build

      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900

      - name: KMS Sign artifact.txt (PS256)
        run: |
          set -euo pipefail
          aws kms sign --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --signing-algorithm RSASSA_PSS_SHA_256 --message-type RAW \
            --message fileb://artifact.txt --query Signature --output text | base64 -d > artifact.sig

      - name: Fetch public key & verify
        run: |
          set -euo pipefail
          aws kms get-public-key --key-id "${{ vars.AWS_KMS_KEY_ID }}" \
            --query PublicKey --output text | base64 -d > aws-pub.der
          openssl pkey -pubin -inform DER -in aws-pub.der -out aws-pub.pem
          openssl dgst -sha256 -verify aws-pub.pem -signature artifact.sig \
            -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:digest -sigopt rsa_mgf1_md:sha256 artifact.txt

      - name: Trust-store check for signer (warn)
        shell: bash
        env:
          KID: AWS:${{ vars.AWS_KMS_KEY_ID }}
          ENF: ${{ env.ENFORCEMENT }}
        run: |
          set -euo pipefail
          ok=0
          test -f .github/trust/publishers.jwks.json && \
            jq -e --arg k "$KID" '.keys[]?|.kid==$k' .github/trust/publishers.jwks.json >/dev/null && ok=1
          revoked=0
          test -f .github/trust/revocations.json && \
            jq -e --arg k "$KID" '.kids[]?|.==$k' .github/trust/revocations.json >/dev/null && revoked=1 || true
          if [ $ok -ne 1 ]; then
            echo "::warning::Signer $KID is NOT in publishers.jwks.json"
            [ "${ENF}" = "block" ] && exit 1 || true
          fi
          if [ $revoked -eq 1 ]; then
            echo "::warning::Signer $KID is REVOKED in revocations.json"
            [ "${ENF}" = "block" ] && exit 1 || true
          fi

      - name: Save signing evidence
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: signing-evidence
          path: |
            artifact.txt
            artifact.sig
            aws-pub.pem
            checksums.txt

  # ---------------- SBOM enforce ----------------
  sbom_enforce:
    needs: [build_and_attest]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: build
      - name: Enforce SBOM digest
        shell: bash
        run: |
          set -euo pipefail
          A=$(sha256sum artifact.txt | awk '{print $1}')
          S=$(jq -r '.files[]?|select(.fileName=="artifact.txt")|.checksums[]?|select(.algorithm=="SHA256")|.checksumValue' sbom.spdx.json | head -n1)
          [ -n "$S" ] && [ "$A" = "$S" ] && echo "SBOM OK" || {
            echo "::warning::SBOM mismatch/missing (artifact=$A, sbom=$S)";
            [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }

  # ---------------- Secrets presence gate ----------------
  secrets_scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Heuristic secret scan (code + workflows + artifacts)
        shell: bash
        run: |
          set -euo pipefail
          grep -RInE 'AKIA|ASIA|BEGIN (RSA |OPENSSH )?PRIVATE KEY|ghp_[A-Za-z0-9]{36,}|xoxb-|SECRET_ACCESS_KEY|password=|token=' \
            -- . ':!**/.git/**' || true
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "::warning::possible secrets found"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          fi

  # ---------------- Change-Reason Gate ----------------
  change_reason_gate:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Require Change-ID/Ticket in PR
        shell: bash
        run: |
          set -euo pipefail
          title=$(jq -r .pull_request.title "$GITHUB_EVENT_PATH")
          body=$(jq -r .pull_request.body  "$GITHUB_EVENT_PATH")
          labels=$(jq -r '.pull_request.labels[].name' "$GITHUB_EVENT_PATH" | tr '\n' ' ')
          echo "$title $body $labels" | grep -Eiq '(Change-ID:|Ticket:|ABC-[0-9]+)' && exit 0
          echo "::warning::No Change-ID/Ticket"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true

  # ---------------- Access recert gate (опционально) ----------------
  access_cert_gate:
    if: ${{ vars.ACCESS_CERT_OK != '' || vars.ACCESS_CERT_EXPIRES != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Access recertification gate
        shell: bash
        env:
          OK: ${{ vars.ACCESS_CERT_OK }}
          EXP: ${{ vars.ACCESS_CERT_EXPIRES }}
        run: |
          set -euo pipefail
          if [ "${OK:-}" != "true" ]; then
            echo "::warning::ACCESS_CERT_OK!=true"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          fi
          if [ -n "${EXP:-}" ]; then
            now=$(date -u +%s)
            exp=$(date -u -d "${EXP}" +%s 2>/dev/null || echo 0)
            [ -z "$exp" ] && exp=0
            if [ "$exp" -ge "$now" ]; then
              echo "access recert valid (expires ${EXP})"
            else
              echo "::warning::access recert expired"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
            fi
          fi

  # ---------------- Org security flags (App) ----------------
  security_settings_guard:
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900

      - name: Fetch GH App private key from Secrets Manager
        shell: bash
        run: |
          set -euo pipefail
          umask 077
          RAW="$(aws secretsmanager get-secret-value --secret-id ci/github/app-private-key --query SecretString --output text)"
          if printf '%s' "$RAW" | head -n1 | grep -q -- '-----BEGIN '; then
            printf '%s' "$RAW" > app.pem
          else
            VAL=$(printf '%s' "$RAW" | jq -r '(.value // .privkey // .key // empty)' 2>/dev/null || true)
            [ -n "${VAL:-}" ] || { echo "::error::Secret is not PEM and no JSON field value/privkey/key"; exit 1; }
            printf '%s' "$VAL" > app.pem
          fi
          openssl pkey -in app.pem -noout >/dev/null

      - name: GH App installation token (no external action)
        id: app_token
        env:
          APP_ID: ${{ secrets.GHAPP_ID }}
          API_URL: ${{ github.api_url }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail
          b64url(){ openssl base64 -A | tr '+/' '-_' | tr -d '='; }
          NOW=$(date +%s); EXP=$((NOW+540))
          HDR=$(printf '{"alg":"RS256","typ":"JWT"}' | b64url)
          PAY=$(printf '{"iat":%s,"exp":%s,"iss":"%s"}' "$NOW" "$EXP" "$APP_ID" | b64url)
          SIG=$(printf %s "$HDR.$PAY" | openssl dgst -sha256 -sign app.pem -binary | b64url)
          JWT="$HDR.$PAY.$SIG"
          API="${API_URL:-https://api.github.com}"
          INST_ID=$(curl -fsSL -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json" "$API/repos/$REPO/installation" | jq -r .id)
          TOKEN=$(curl -fsSL -X POST -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json" "$API/app/installations/$INST_ID/access_tokens" | jq -r .token)
          echo "GH_TOKEN=$TOKEN" >> "$GITHUB_ENV"; rm -f app.pem

      - name: Check repo security flags (secret scanning + push protection)
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          DATA=$(gh api -H "Accept: application/vnd.github+json" repos/${{ github.repository }})
          SS=$(jq -r '.security_and_analysis.secret_scanning.status // empty' <<<"$DATA")
          PP=$(jq -r '.security_and_analysis.secret_scanning_push_protection.status // empty' <<<"$DATA")
          [ "$SS" = "enabled" ] && [ "$PP" = "enabled" ] && echo "Secret scanning OK" || { echo "::error::enable Secret scanning + Push Protection"; exit 1; }

  # ---------------- Encrypted-at-rest policy (backups) ----------------
  encrypted_at_rest_policy:
    if: ${{ vars.BACKUP_BUCKET != '' }}
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
      - name: Enforce SSE-KMS on backup bucket
        env:
          B: ${{ vars.BACKUP_BUCKET }}
        run: |
          set -euo pipefail
          enc=$(aws s3api get-bucket-encryption --bucket "$B" \
             --query 'ServerSideEncryptionConfiguration.Rules[0].ApplyServerSideEncryptionByDefault.SSEAlgorithm' \
             --output text 2>/dev/null || echo "NONE")
          if [ "$enc" != "aws:kms" ]; then
            echo "::warning::Bucket $B not SSE-KMS"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          fi
      - name: Enforce lifecycle >=30 days
        env:
          B: ${{ vars.BACKUP_BUCKET }}
        run: |
          set -euo pipefail
          lc=$(aws s3api get-bucket-lifecycle-configuration --bucket "$B" 2>/dev/null || echo "")
          days=$(jq -r '[.Rules[]?.Expiration?.Days // empty] | max // 0' <<<"$lc")
          if [ "${days:-0}" -lt 30 ]; then
            echo "::warning::No Expiration >=30d on $B"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          fi

  # ---------------- Permissions gate (token scopes) ----------------
  permissions_gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Lint permissions (deny dangerous writes)
        run: |
          set -euo pipefail
          bad=$(grep -RInE 'permissions:\s*(write-all|{[^}]*: *write[^}]*})' .github/workflows || true)
          if [ -n "$bad" ]; then
            echo "$bad"
            echo "::warning::dangerous token permissions found"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          else
            echo "permissions OK"
          fi
      - name: Deny interactive signing patterns
        shell: bash
        run: |
          set -euo pipefail
          bad=$(grep -RInE '\bgpg(\.exe)?\b.*\b(--sign|-s)\b|openssl .* -passin +(pass:|env:|file:|-)|ssh-keygen .* -P( |$)' \
                -- . ':!**/.git/**' 2>/dev/null || true)
          if [ -n "$bad" ]; then
            echo "::error::interactive signing patterns found"
            echo "$bad"
            exit 1
          fi

  # ---------------- Audit streaming guard (S3) ----------------
  audit_streaming_guard:
    if: ${{ vars.AUDIT_BUCKET != '' }}
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-duration-seconds: 900
      - name: Check bucket exists
        env:
          B: ${{ vars.AUDIT_BUCKET }}
        run: |
          set -euo pipefail
          aws s3api head-bucket --bucket "$B" || { echo "::error::Bucket $B not found"; exit 1; }
      - name: Saw audit objects in last 7d
        env:
          B: ${{ vars.AUDIT_BUCKET }}
          P: ${{ vars.AUDIT_PREFIX }}
        run: |
          set -euo pipefail
          since=$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ)
          aws s3api list-objects-v2 --bucket "$B" --prefix "${P:-}" --query \
            "Contents[?LastModified>=\`$since\`][].{Key:Key,LastModified:LastModified}" \
            --output json | jq -e 'length>0' >/dev/null || {
              echo "::warning::no audit objects in last 7d"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }
      - name: Probe latest object for 'deployment_status' (best-effort)
        env:
          B: ${{ vars.AUDIT_BUCKET }}
          P: ${{ vars.AUDIT_PREFIX }}
        run: |
          set -euo pipefail
          obj=$(aws s3api list-objects-v2 --bucket "$B" --prefix "${P:-}" --query 'reverse(sort_by(Contents,&LastModified))[0].Key' --output text)
          if [ "$obj" != "None" ]; then
            aws s3 cp "s3://$B/$obj" - | gzip -dc 2>/dev/null | grep -q '"action":"deployment_status"' && echo "deployment_status found" || \
              echo "::notice::no deployment_status in latest object (может и нормально)"
          else
            echo "::notice::bucket empty"
          fi
      - name: Lifecycle retention >=90d
        env:
          B: ${{ vars.AUDIT_BUCKET }}
        run: |
          set -euo pipefail
          lc=$(aws s3api get-bucket-lifecycle-configuration --bucket "$B" 2>/dev/null || echo "")
          days=$(jq -r '[.Rules[]?.Expiration?.Days // empty] | max // 0' <<<"$lc")
          if [ "${days:-0}" -lt 90 ]; then
            echo "::warning::No lifecycle expiration >=90d on $B"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true
          fi

  # ---------------- Rerun guard (best-effort dual-control) ----------------
  rerun_guard:
    runs-on: ubuntu-latest
    steps:
      - name: Block rerun without explicit approval (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          ATTEMPT: ${{ github.run_attempt }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if [ "${ATTEMPT:-1}" -gt 1 ]; then
            pr=$(jq -r .number "$GITHUB_EVENT_PATH")
            labels=$(gh pr view "$pr" --json labels -q '.labels[].name' | tr '\n' ' ')
            echo "$labels" | grep -q 'Re-Run-Approved' || {
              echo "::warning::Rerun needs label Re-Run-Approved"; [ "${ENFORCEMENT}" = "block" ] && exit 1 || true; }
          else
            echo "first attempt -> OK"
          fi

  # ---------------- Release-only gate + trust-store verify for deploy ----------------
  prod_release_gate:
    needs: [build_and_attest, trust_store_guard, kms_sign_and_verify, sbom_enforce, verify_action_publishers]
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - name: Enforce release-only refs
        shell: bash
        run: |
          set -euo pipefail
          case "${GITHUB_REF}" in refs/heads/main|refs/heads/release/*|refs/tags/v*) ;; *)
            echo "::error::Deploy allowed only from main/release/*/v*"; exit 1;; esac
      - name: Check key revocations
        run: |
          set -euo pipefail
          test -f .github/trust/revocations.json || { echo "no revocations.json -> OK"; exit 0; }
          KID="AWS:${{ vars.AWS_KMS_KEY_ID }}"
          jq -r '.kids[]?' .github/trust/revocations.json | grep -Fx "$KID" && {
            echo "::error::Key revoked ($KID)"; exit 1; } || echo "KID not revoked"
      - name: Enforce signer present in JWKS (unknown ⇒ block)
        shell: bash
        env:
          KID: AWS:${{ vars.AWS_KMS_KEY_ID }}
        run: |
          set -euo pipefail
          test -f .github/trust/publishers.jwks.json || { echo "::error::missing .github/trust/publishers.jwks.json"; exit 1; }
          jq -e --arg k "$KID" '.keys[]?|.kid==$k' .github/trust/publishers.jwks.json >/dev/null \
            || { echo "::error::unknown signer $KID (not in .github/trust/publishers.jwks.json)"; exit 1; }
      - name: Verify OIDC claims + allowed_signers
        shell: bash
        run: |
          set -euo pipefail
          tok=$(curl -sS -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
                "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=sts.amazonaws.com" | jq -r .value)
          test -n "$tok"
          body=$(echo "$tok" | awk -F. '{print $2}' | base64 -d 2>/dev/null)
          repo=$(jq -r .repository <<<"$body")
          ref=$(jq -r .ref <<<"$body")
          wf=$(jq -r .job_workflow_ref <<<"$body")
          [ "$repo" = "${GITHUB_REPOSITORY}" ] || { echo "::error::OIDC repo mismatch"; exit 1; }
          echo "$ref" | grep -Eq '^refs/(heads/(main|release/.*)|tags/v.*)$' || { echo "::error::OIDC ref not allowed"; exit 1; }
          jq -r '.[]?' .github/trust/allowed_signers.json | grep -Fx "$wf" >/dev/null || {
            echo "::error::workflow not in allowed_signers"; exit 1; }

  # ---------------- Promote to Production (env approvals enforced в UI) ----------------
  promote_to_prod:
    needs: [prod_release_gate]
    runs-on: ubuntu-latest
    environment:
      name: production
    concurrency:
      group: deploy-${{ github.ref_name }}
      cancel-in-progress: true
    steps:
      - run: echo "All upstream gates passed. Waiting for env approval…"

  # ---------------- Trust-store auto-rotation (по расписанию) ----------------
  trust_store_rotate:
    if: ${{vars.ORG_TRUST_REPO != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Pull org trust-store
        env:
          ORG_TRUST_REPO: ${{ vars.ORG_TRUST_REPO }}
        run: |
          set -euo pipefail
          rm -rf _orgtrust
          gh repo clone "$ORG_TRUST_REPO" _orgtrust -- -q
          test -d _orgtrust/.github/trust || { echo "no .github/trust in $ORG_TRUST_REPO"; exit 0; }
          mkdir -p .github/trust
          cp -a _orgtrust/.github/trust/. .github/trust/
      - name: Detect changes
        id: diff
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BR="chore/rotate-trust-store-$(date -u +%Y%m%d%H%M%S)"
          git checkout -b "$BR"
          git add .github/trust
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            git commit -m "chore(trust-store): sync from ${{ vars.ORG_TRUST_REPO }}"
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "branch=$BR" >> "$GITHUB_OUTPUT"
          fi
      - name: Open PR
        if: steps.diff.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh pr create \
            --title "chore(trust-store): sync org trust-store" \
            --body "Automated sync of .github/trust from \`${{ vars.ORG_TRUST_REPO }}\`" \
            --base "main" || true
